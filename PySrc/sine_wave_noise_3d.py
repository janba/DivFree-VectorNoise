import numpy as np
import math


class SineWaveNoise3D:
    """
    3D noise generator based on sum of sine waves with random directions and amplitudes.
    
    This noise is generated by:
    1. Creating N random unit vectors (directions)
    2. Assigning random amplitudes to each direction
    3. Computing noise as sum of sine waves: amplitude * sin(2π * dot(position, direction))
    
    The resulting noise has wave-like characteristics and is infinitely differentiable.
    """
    
    def __init__(self, num_waves=32, seed=None, frequency_scale=1.0):
        """
        Initialize the sine wave noise generator.
        
        Args:
            num_waves (int): Number of sine waves to sum (more waves = more complex noise)
            seed (int, optional): Random seed for reproducible noise
            frequency_scale (float): Global frequency scaling factor
        """
        if seed is not None:
            np.random.seed(seed)
        
        self.num_waves = num_waves
        self.frequency_scale = frequency_scale
        
        # Generate random unit vectors (directions for wave propagation)
        # Use normal distribution and normalize to get uniform distribution on sphere
        directions = np.random.randn(num_waves, 3)
        # Normalize to unit vectors
        norms = np.linalg.norm(directions, axis=1, keepdims=True)
        # Avoid division by zero (extremely unlikely)
        norms = np.where(norms < 1e-10, 1e-10, norms)
        self.directions = directions / norms
        
        # Generate random amplitudes (positive and negative for variety)
        self.amplitudes = np.random.uniform(-1.0, 1.0, num_waves)
        
        # Normalize amplitudes so the total expected magnitude is reasonable
        self.amplitudes /= np.sqrt(num_waves)
        
        # Pre-compute 2π for efficiency
        self.two_pi = 2.0 * math.pi
    
    def noise_and_gradient(self, x, y, z):
        """
        Compute both sine wave noise value and its gradient at point (x, y, z).
        
        The noise function is: Σ(amplitude_i * sin(2π * frequency_scale * dot([x,y,z], direction_i)))
        The gradient is: Σ(amplitude_i * 2π * frequency_scale * cos(2π * frequency_scale * dot([x,y,z], direction_i)) * direction_i)
        
        Args:
            x, y, z (float): Coordinates in 3D space
            
        Returns:
            tuple: (noise_value, gradient_vector)
                noise_value (float): Sine wave noise value at (x, y, z)
                gradient_vector (numpy.ndarray): 3D gradient vector [dx, dy, dz]
        """
        position = np.array([x, y, z])
        
        # Compute dot products of position with all directions
        # Shape: (num_waves,)
        dot_products = np.dot(self.directions, position)
        
        # Scale by frequency
        scaled_dots = self.frequency_scale * dot_products
        
        # Compute phase angles
        phases = self.two_pi * scaled_dots
        
        # Compute sine and cosine values for all waves
        sin_values = np.sin(phases)
        cos_values = np.cos(phases)
        
        # Compute noise value as weighted sum of sine waves
        noise_value = np.sum(self.amplitudes * sin_values)
        
        # Compute gradient
        # For each wave: amplitude * 2π * frequency_scale * cos(phase) * direction
        gradient_contributions = (
            self.amplitudes[:, np.newaxis] * 
            self.two_pi * 
            self.frequency_scale * 
            cos_values[:, np.newaxis] * 
            self.directions
        )
        
        # Sum contributions from all waves
        gradient = np.sum(gradient_contributions, axis=0)
        
        return noise_value, gradient
    
    def noise(self, x, y, z):
        """
        Compute only the sine wave noise value at point (x, y, z).
        
        Args:
            x, y, z (float): Coordinates in 3D space
            
        Returns:
            float: Sine wave noise value at (x, y, z)
        """
        noise_value, _ = self.noise_and_gradient(x, y, z)
        return noise_value
    
    def gradient(self, x, y, z):
        """
        Compute only the gradient at point (x, y, z).
        
        Args:
            x, y, z (float): Coordinates in 3D space
            
        Returns:
            numpy.ndarray: 3D gradient vector [dx, dy, dz]
        """
        _, gradient = self.noise_and_gradient(x, y, z)
        return gradient
    
    def get_wave_info(self):
        """
        Get information about the constituent waves.
        
        Returns:
            dict: Dictionary containing directions, amplitudes, and other parameters
        """
        return {
            'num_waves': self.num_waves,
            'frequency_scale': self.frequency_scale,
            'directions': self.directions.copy(),
            'amplitudes': self.amplitudes.copy(),
            'max_amplitude': np.max(np.abs(self.amplitudes)),
            'total_amplitude': np.sum(np.abs(self.amplitudes))
        }
    
    def noise_vectorized(self, positions):
        """
        Compute noise values for multiple positions efficiently.
        
        Args:
            positions (numpy.ndarray): Array of shape (N, 3) containing N 3D positions
            
        Returns:
            numpy.ndarray: Array of shape (N,) containing noise values
        """
        # positions shape: (N, 3)
        # directions shape: (num_waves, 3)
        # Result shape: (N, num_waves)
        dot_products = np.dot(positions, self.directions.T)
        
        # Scale by frequency and compute phases
        phases = self.two_pi * self.frequency_scale * dot_products
        
        # Compute sine values
        sin_values = np.sin(phases)
        
        # Weight by amplitudes and sum over waves
        # sin_values shape: (N, num_waves)
        # amplitudes shape: (num_waves,)
        noise_values = np.dot(sin_values, self.amplitudes)
        
        return noise_values


# Example usage and testing
if __name__ == "__main__":
    # Create noise generator
    noise_gen = SineWaveNoise3D(num_waves=64, seed=42, frequency_scale=0.5)
    
    # Test single point
    x, y, z = 1.5, 2.3, 0.8
    noise_val, grad = noise_gen.noise_and_gradient(x, y, z)
    
    print(f"Sine Wave Noise Test")
    print(f"Point: ({x}, {y}, {z})")
    print(f"Noise value: {noise_val:.6f}")
    print(f"Gradient: [{grad[0]:.6f}, {grad[1]:.6f}, {grad[2]:.6f}]")
    print(f"Gradient magnitude: {np.linalg.norm(grad):.6f}")
    
    # Test gradient accuracy with numerical differentiation
    epsilon = 1e-6
    noise_val_dx, _ = noise_gen.noise_and_gradient(x + epsilon, y, z)
    noise_val_dy, _ = noise_gen.noise_and_gradient(x, y + epsilon, z)
    noise_val_dz, _ = noise_gen.noise_and_gradient(x, y, z + epsilon)
    
    numerical_grad = np.array([
        (noise_val_dx - noise_val) / epsilon,
        (noise_val_dy - noise_val) / epsilon,
        (noise_val_dz - noise_val) / epsilon
    ])
    
    print(f"\nGradient verification:")
    print(f"Analytical: [{grad[0]:.6f}, {grad[1]:.6f}, {grad[2]:.6f}]")
    print(f"Numerical:  [{numerical_grad[0]:.6f}, {numerical_grad[1]:.6f}, {numerical_grad[2]:.6f}]")
    print(f"Max difference: {np.max(np.abs(grad - numerical_grad)):.8f}")
    
    # Show wave information
    wave_info = noise_gen.get_wave_info()
    print(f"\nWave Information:")
    print(f"Number of waves: {wave_info['num_waves']}")
    print(f"Frequency scale: {wave_info['frequency_scale']}")
    print(f"Max amplitude: {wave_info['max_amplitude']:.6f}")
    print(f"Total amplitude: {wave_info['total_amplitude']:.6f}")
    
    # Test vectorized computation
    test_positions = np.random.rand(1000, 3) * 10  # 1000 random positions
    noise_values = noise_gen.noise_vectorized(test_positions)
    print(f"\nVectorized test:")
    print(f"Computed noise for {len(test_positions)} positions")
    print(f"Noise range: [{np.min(noise_values):.6f}, {np.max(noise_values):.6f}]")
    print(f"Noise std: {np.std(noise_values):.6f}")